<?php

namespace Blockchain\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;

class IndexController extends AbstractActionController
{

    public function indexAction()
    {
        return new ViewModel();
    }

    public function loadAction()
    {/*{{{*/
        echo "
Todo:

1. is flush called automatically at any point? (it appears that non-flushed changes are saved to DB on ctrl-c
2. is flush is atomic (if not need to check if transactions, inputs, and outputs are complete for last block)
3. how to extract public keys
4. does block 0 have value and transactions
5. is totalvalue for block just the new value generated by that block, or entire blockchain value
6. is fee calculation correct
7. how to extract hash160
8. move code out of controller

";

        sleep(3);

        $this->config = $this->getServiceLocator()->get('config');

        // this can take a long time
        set_time_limit(0);

        $objectManager = $this
            ->getServiceLocator()
            ->get('Doctrine\ORM\EntityManager');

        $client = new \Zend\Json\Server\Client($this->config['bitcoind']['server']);
        $client->getHttpClient()->setOptions(array('timeout' => 30));
        $blockcount = $client->call('getblockcount');

        $resume = false;
        // Get the last block in the DB
        $query = $objectManager->createQuery('SELECT b FROM Blockchain\Entity\Block b WHERE b.id = (SELECT MAX(bm.id) FROM Blockchain\Entity\Block bm)');
        $result = $query->getResult();
        if (count($result) == 1) {
            $resume = true;
            // always redo the last hash in the DB, because it might have a "nextblockhash" when it was null before
            $blockEntity = $result[0];
            $blockhash = $blockEntity->getBlockhash();
            $block = $this->getBlock($blockhash);
            if (isset($block['nextblockhash']) && !$blockEntity->getNextblockhash()) {
                $blockEntity->setNextblockhash($block['nextblockhash']);
                $objectManager->flush();
                $objectManager->clear();
            }
            $blockhash = $blockEntity->getNextblockhash();
            $blockNumber = $blockEntity->getBlockNumber() + 1;
            $coinbaseExp = floor(($blockNumber) / 210000);
            $coinbaseValue = 50 / pow(2, $coinbaseExp);
        } else {
            $blockNumber = 0;
            $blockhash = $client->call('getblockhash', array($blockNumber));
            $coinbaseValue = 50;
        }

        $batchSize = 25; 

        $count = 0;
        // Start importing 
        while($blockhash) {
            $count++;
            if ($blockNumber % 210000 == 0) {
                // only calculate this when necessary instead of every loop
                $coinbaseExp = floor(($blockNumber) / 210000);
                $coinbaseValue = 50 / pow(2, $coinbaseExp);
            }
            
            echo "Importing Block: $blockNumber\n";

            $totalValue = 0;

            $block = $this->getBlock($blockhash);

            $blockEntity = new \Blockchain\Entity\Block();

            // First block is unique
            if ($blockNumber > 0) {
                foreach ($block['tx'] as $txid) {
                    // the JSON RPC client appears to have a memory leak, so isolate it inside a function
                    $transaction = $this->getRawTransaction($txid);
                    
                    if (!$transaction) {
                        die('failure retrieving transaction');
                    }

                    $transactionEntity = new \Blockchain\Entity\Transaction();

                    $inputValue = 0;

                    foreach ($transaction['vin'] as $input) {
                        $inputEntity = new \Blockchain\Entity\Input();
                        $inputEntity->setTxid($txid);
                        $inputEntity->setSequence($input['sequence']);
                        if (isset($input['coinbase'])) {
                            $inputEntity->setCoinbase($input['coinbase']);
                            $inputEntity->setValue($coinbaseValue);
                            $inputValue = $inputValue + $coinbaseValue;
                        } else {
                            $inputEntity->setScriptSigAsm($input['scriptSig']['asm']);
                            $inputEntity->setScriptSigHex($input['scriptSig']['hex']);
                            $inputEntity->setVout($input['vout']);
                            $previousOutputEntity = $objectManager->getRepository('Blockchain\Entity\Output')->findOneBy(array('txid' => $input['txid'], 'index' => $input['vout']));
                            $inputEntity->setValue($previousOutputEntity->value);
                            $inputValue = $inputValue + $inputEntity->getValue();
                            // Need to figure out how to extract hash160, if it is of any value...
                            // $inputEntity->setHash160();
                        }
                        $inputEntity->setTransaction($transactionEntity);
                        $objectManager->persist($inputEntity);
                    }

                    $totalValue = $totalValue + $inputValue;

                    $outputValue = 0;

                    foreach ($transaction['vout'] as $output) {
                        $outputEntity = new \Blockchain\Entity\Output();
                        $outputEntity->setTxid($txid);
                        $outputEntity->setIndex($output['n']);
                        $outputEntity->setValue($output['value']);
                        $outputValue = $outputValue + $output['value'];
                        $outputEntity->setScriptPubKeyAsm($output['scriptPubKey']['asm']);
                        $outputEntity->setScriptPubKeyHex($output['scriptPubKey']['hex']);
                        $outputEntity->setReqSigs($output['scriptPubKey']['reqSigs']);
                        $outputEntity->setType($output['scriptPubKey']['type']);
                        $outputEntity->setAddress($output['scriptPubKey']['addresses'][0]);
                        // Need to figure out how to extract hash160, if it is of any value...
                        // $outputEntity->setHash160();
                        $outputEntity->setTransaction($transactionEntity);
                        $objectManager->persist($outputEntity);
                    }

                    $transactionEntity->setTxid($transaction['txid']);
                    $transactionEntity->setBlock($blockEntity);
                    $transactionEntity->setVersion($transaction['version']);
                    $transactionEntity->setLocktime($transaction['locktime']);
                    $transactionEntity->setFee($inputValue - $outputValue);
                    $objectManager->persist($transactionEntity);
                    break;
                }
            }

            $blockEntity->setBlockNumber($blockNumber);
            $blockEntity->setBlockhash($block['hash']);
            $blockEntity->setSize($block['size']);
            $blockEntity->setHeight($block['height']);
            $blockEntity->setVersion($block['version']);
            $blockEntity->setMerkleroot($block['merkleroot']);
            $blockEntity->setTime(new \DateTime('@'.$block['time']));
            $blockEntity->setNonce($block['nonce']);
            $blockEntity->setBits($block['bits']);
            $blockEntity->setDifficulty($block['difficulty']);
            $blockEntity->setTotalvalue($totalValue);

            if (isset($block['nextblockhash'])) {
                $nextblockhash = $block['nextblockhash'];
                $blockEntity->setNextblockhash($block['nextblockhash']);
            } else {
                $nextblockhash = null;
            }
            if (isset($block['previousblockhash'])) {
                $blockEntity->setPreviousblockhash($block['previousblockhash']);
            }
            $objectManager->persist($blockEntity);
            $objectManager->flush();
            $objectManager->clear();
            if ($count  % $batchSize == 0 || !$blockhash) {
                echo "\nwriting data to DB...\n\n";
            }
            $blockhash = $nextblockhash;
            $blockNumber++;
        }
        
        return new ViewModel();
    }/*}}}*/

    // the JSON RPC client appears to have a memory leak, so isolate it inside a function
    protected function getBlock($hash)
    {/*{{{*/
        $client = new \Zend\Json\Server\Client($this->config['bitcoind']['server']);
        $client->getHttpClient()->setOptions(array('timeout' => 30));

        $retryCount = 3;
        $block = null;
        do {
            $queryFailed = false;
            try {
                $block = $client->call('getblock', array($hash));
            } catch (Zend\Http\Client\Adapter\Exception $e) {
                echo $e->getMessage();
                $queryFailed = true;
                // sleep 100ms
                usleep(200000);
            }
            $retryCount--;
        } while ((!$block || $queryFailed) && $retryCount);

        return $block;
    }/*}}}*/

    // the JSON RPC client appears to have a memory leak, so isolate it inside a function
    protected function getTransaction($hash)
    {/*{{{*/
        $client = new \Zend\Json\Server\Client($this->config['bitcoind']['server']);
        $client->getHttpClient()->setOptions(array('timeout' => 30));

        $retryCount = 3;
        $transaction = null;
        do {
            $queryFailed = false;
            try {
                $transaction = $client->call('gettransaction', array($hash));
            } catch (Zend\Http\Client\Adapter\Exception $e) {
                echo $e->getMessage();
                $queryFailed = true;
                // sleep 100ms
                usleep(200000);
            }
            $retryCount--;
        } while ((!$transaction || $queryFailed) && $retryCount);

        return $transaction;
    }/*}}}*/

    // the JSON RPC client appears to have a memory leak, so isolate it inside a function
    protected function getRawTransaction($hash)
    {/*{{{*/
        $client = new \Zend\Json\Server\Client($this->config['bitcoind']['server']);
        $client->getHttpClient()->setOptions(array('timeout' => 30));

        $retryCount = 3;
        $transaction = null;
        do {
            $queryFailed = false;
            try {
                $rawTransaction = $client->call('getrawtransaction', array($hash));
                $transaction = $client->call('decoderawtransaction', array($rawTransaction));
            } catch (Zend\Http\Client\Adapter\Exception $e) {
                echo $e->getMessage();
                $queryFailed = true;
                // sleep 100ms
                usleep(200000);
            }
            $retryCount--;
        } while ((!$transaction || $queryFailed) && $retryCount);

        return $transaction;
    }/*}}}*/

}

